# Basic Programming 
## Simple Procedures


A Maple procedure (a type of program) is a group of statements  that are processed together. The easiest way to create a Maple procedure is to enclose a sequence of commands, which can be used to perform a computation interactively, between the `proc(...)` and `end proc` statements.

A Maple procedure has the following syntax:

```
proc(seqvar)
statseq ;
end;
```
where

- `seqvar` is a sequence of symbols of inputs separated by commas, and 
- `statseq` is a sequence of statements separated by semicolons.

The following procedure generates the string "Hello World". Enter this procedure in a Maple session by entering its definition on one line. If **no input is required to run a procedure**, that is, no formal parameters are required; **enter empty parentheses in the heading of the procedure** definition and in procedure calls.





### Procedures with no inputs (parameters)

```
[> hello:= proc() "Hello , This is my first Programm " ;end proc;
[> hello ( ) ;
```

![](figures/program/fig1.png)
> Remark: You can also enter a procedure or any Maple statement on multiple lines. To move the cursor to the next line as you are entering a multi line statement, hold the `Shift` key and press `Enter` at the end of each line.

```
[> hello:=proc()
"Hello , This is my first Programm ;
end proc;
[> hello();
````

![](figures/program/fig2.png)
You can also use the `return` command to return the evaluated statement or a value
```
[> hello:=proc()
return "Hello , This is my first Programm ;
end proc;
[> hello();
````

![](figures/program/fig3.png)

### Procedures with inputs (parameters)
Procedures can also accept arguments. Consider following exmpale


```{example}
Compute the half of the value of a given value.
```

```
[> half:=proc(x)
evlaf(x/2);
end proc;

[> half(5);
```

![](figures/program/fig4.png)
This procedure requires one input, $x$. The procedure computes the approximation of the value of $x$ divided by $2$. When a return statement is not specified, a Maple procedure returns the result of the last statement that was run.

```
[> half(7)+half(8);
```

![](figures/program/fig5.png)

```{example}
Compute the average of two given numbers
```

```
[> Average:=proc(x,y)
(x+y) / 2
end proc;

[> Average(7,12) ;
[> evalf(%) ;
[> evalf(Average(254,789));
```

![](figures/program/fig6.png)


```{example}
Compute the area of a cylinder
```
![](figures/program/fig8.jpeg)


```
[> area_of_cylinder:=proc(r,h)
2*Pi*r*h+2*Pi*r^2;
end proc ;

[> area_of_cylinder(4,15);
[> evalf(%)
```
![](figures/program/fig7.png)


```{example}
Solve the quadric equations when the coefficients are given.
```

```
[> s:=proc(a,b,c)
solve(a*x^2+b*x+c,x)
end proc;

[> s(1,-4,3); # Roots of x^2-4x+3=0
[> s(1,0,1); # Roots of x^2+1=0
```

![](figures/program/fig8.png)


```{example}
The follovving procedure will solve $x^n-1=0$ for specific value of $n$.
```

```
[> solution:=proc (n)
solve(x^n—1,x);
end proc;


[> solution(1);
[> solution(2);
[> solution(4);
[> seq(solution(i),i=1..5);
```

![](figures/program/fig9.png)

## Procedures with local variables
```{example} 
Finding the volume of a right rectangular pyramid.
```


![](figures/program/fig10.jpg)


```
[> Volume_of_Right_rectangular_pyramid:=proc(l,w,h)
local V;
V:=evalf((l*w*h)/3) ;
end;

[> Volume_of_Right_rectangular_pyramid(21,8,7);
```

![](figures/program/fig10.png)
```{example}
The following procedure definition contains two input parameters for the length of sides of a right triangle. It calculates the theta value in degree form.
```

![](figures/program/fig11.png)


```
[> GetAng1e:= proc(opposite,hypotenuse)
local theta;
theta:=arcsin(opposite/hypotenuse);
evalf(180/Pi*theta) ;
end proc ;


[> GetAng1e(4,5);
```

![](figures/program/fig12.png)

The local variables can be thought as "scratch pad variables", or "temporary variable?' Local variables are used to hold temporary results that might come up while we are trying to compute our main result in the procedure. As we will see. the local variables only "live" inside the procedure call. They do not exist outside the procedure, and they do not survive from one procedure call to the next (this is why they get their name "local"). The global variable is just that. it is global to the whole Maple worksheet. As we will see, global variables inside procedure bodies are really the same as the variables we use in commands at our worksheet prompts.

```{exmaple}
.
```

```
[> plus:proc(x,y)
local a,b;
global c;
a:=x-y;
b:=x*y;
c:=x^y;
end;


[> plus(2,5);
[> a;
[> b;
[> c;
```
![](figures/program/fig13.png)

The following example contains three local variables. You should define all the variable that you used as the local within your procedure.


```{example}
This example shows how calculate the average value for a given list.
```
```
[> avg1:= proc(L)
local i,N,S; # Local variables.
N := nops(L); # How many numbers we are averaging.
S := add(L[i],i=1..N); # Add up the nurnbers in the list.
S/N; # This is the return value .
end ;


[> avg([2,3,4,5,6,7]);
[> evalf(%);
```
![](figures/program/fig14.png)


## Exercise 01


1. Write Maple procedures to calculate the sum of the squares of two numbers you entered. Hence calculate the sum of the squares of 629 and 1 1 1 1.

2. Use Maple to show that the sum of first n positive integers is given by,$\frac{n(n+l)}{2}$
  
3. Write a maple procedure to check whether a product of two given integers is prime or not. Verify your procedure.

04. Find the area of a triangle with 3 sides given. $(\text{Area} =\sqrt{s(s-a)(s-b)(s-c)}$ where $s=\frac{a+b+c}{2}$ and $a, b, c$ are the length of the each side of triangle). Find the area of the triangle with each side of $5,7,9$.

05. Write a procedure to convert two binary numbers into decimal and return their summation. (try out your procedure with $110010, 11001100$)



## Conditional Statements

Suppose that you want a sequence of commands to be carried out if and only if a certain condition is satisfied.  This often happens when you are writing the definition ofa procedure.  You can achieve the desired effect with an `if... then` construction. but first you need to know how you can express conditions in Maple.



```
then
[> if conditional_statement1 then
     statemnet_sequnce1
   elif conditional_statement2 then
     statemnet_sequnce2
   elif conditional_statement3 then
     statemnet_sequnce3
   ...
   else
    statemnet_sequnceN
  end if;
```

The elif conditional expression then construct can appear zero, one, or many times. The else construct can be excluded.

The conditional expression (expr) in the if clause is evaluated. The conditional expression can be any Boolean expression, which evaluates to true, false, or FAIL, formed by using:

- relational operators: `<` (less than), `<=` (less than or equal), `=` (equal), and `<>` (not equal)
- logical operators: `and`, `or`, and `not`
- logical names: `true`, `false`, and `FAIL`


If the result of the if clause is the Boolean value true, Maple executes the statement sequence in the then clause. If the result of the if clause is the Boolean value false or FAIL, Maple executes the statement sequence in the else clause (if there is one).

```
[> x:=-2;
[> if x<0 then
0
else
1
end if;
```
![](figures/program/fig15.png)

You can omit the else clause if you do not want to specify an action if the condition is false.

```
[> if x>0 then
  x:=x-1;
  end if;
```

### Nested Selection Statements

A selection statement can be nested that is, the statement sequence in the then clause or else clause can be any statement (or sequence of statements); including an if statement.

```
[> if x>0 then
print("Positive")
else
  if x=0 then
  print("Zero")
  else
  print("Negative")
  end if
end if;
```

![](figures/program/fig16.png)


General Forms of the if Statement For more complicated scenarios, use one of the following two forms of the if statement.


```
if expr1 then
  statseq1
elif expr2 then
  statseq2
end if
```

```
if expr1 then
  statseq1
elif expr2 then
  statseq2
else
  statseq3
end if
```

The elif expr then statseq construct can appear more than once. The following example implements the mathematical sign function by using an `elif` clause.

```
[> x:=2;
[> if x<0 then
    -1
elif x=0 then
     0
else
     1
end if;
```
![](figures/program/fig17.png)

We can also include those `if—else` commnands into a maple procedure.

```{example}
The following procedure is to display the grade obtained by the mark.
```

```
[> Grade:=proc (M)
if M>=50 then "pass"
else "fail"
end if;
end proc;

[> Grade(49);
[> Grade(51);
```


![](figures/program/fig18.png)


More than one "if" 


```{example}
.
```

```
[> Grade:=proc(M)
if   M>=75 then A
elif M>=50 then B
elif M>35  then C
else D
end if;
end proc;

[> Grade(75);
[> Grade(42);
[> Grade(60);
```
> You can use `fi` intstead of `end if`
![](figures/program/fig19.png)

```{example}
This procedure can be used to check whether a given number is a perfect or not.
```

```{definition}
A *perfect number* is a positive integer that is equal to the sum of its positive proper divisors.
```

```
[> with (numtheory):
[> is_perfect :=proc(n)
if sigma(n)=2*n then
return true ;
else
return false;
end if;
end proc;

[> is_perfect(6);
```

![](figures/program/fig20.png)

> Note: There is diffrence between `sigma(n)` and `Sigma(n)`


 

### The `'if'` Operator